package com.nftworlds.wallet.contracts.nftworlds;

import com.nftworlds.wallet.NFTWorlds;
import com.nftworlds.wallet.config.Config;
import com.nftworlds.wallet.contracts.wrappers.ethereum.EthereumWRLDToken;
import com.nftworlds.wallet.contracts.wrappers.polygon.PolygonWRLDToken;
import com.nftworlds.wallet.event.PeerToPeerPayEvent;
import com.nftworlds.wallet.event.PlayerTransactEvent;
import com.nftworlds.wallet.objects.Network;
import com.nftworlds.wallet.objects.TransactionObjects;
import com.nftworlds.wallet.objects.Wallet;
import com.nftworlds.wallet.objects.payments.PaymentRequest;
import com.nftworlds.wallet.objects.payments.PeerToPeerPayment;
import com.nftworlds.wallet.rpcs.Ethereum;
import com.nftworlds.wallet.rpcs.Polygon;
import com.nftworlds.wallet.util.LogUtil;
import io.reactivex.disposables.Disposable;
import org.bukkit.Bukkit;
import org.bukkit.OfflinePlayer;
import org.jetbrains.annotations.NotNull;
import org.web3j.abi.FunctionReturnDecoder;
import org.web3j.abi.TypeReference;
import org.web3j.abi.datatypes.Address;
import org.web3j.abi.datatypes.Type;
import org.web3j.abi.datatypes.generated.Uint256;
import org.web3j.crypto.Credentials;
import org.web3j.crypto.Hash;
import org.web3j.protocol.core.DefaultBlockParameterName;
import org.web3j.protocol.core.methods.request.EthFilter;
import org.web3j.protocol.core.methods.response.Log;
import org.web3j.tx.FastRawTransactionManager;
import org.web3j.tx.gas.StaticGasProvider;
import org.web3j.utils.Convert;

import java.math.BigInteger;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.logging.Level;

public class WRLD {
    public static final String TRANSFER_EVENT_TOPIC = Hash.sha3String("Transfer(address,address,uint256)");
    public static final String TRANSFER_REF_EVENT_TOPIC = Hash.sha3String("TransferRef(address,address,uint256,uint256)");

    private final EthereumWRLDToken ethereumWRLDTokenContract;
    private final PolygonWRLDToken polygonWRLDTokenContract;
    private final boolean debug;

    private Disposable flowableSubscription;

    public WRLD() {
        NFTWorlds nftWorlds = NFTWorlds.getInstance();
        Ethereum ethereumRPC = nftWorlds.getEthereumRPC();
        Polygon polygonRPC = nftWorlds.getPolygonRPC();
        Config config = nftWorlds.getNftConfig();
        Credentials credentials = Credentials.create(NFTWorlds.getInstance().getNftConfig().getServerPrivateKey()); //We're only reading so this can be anything
        NFTWorlds.getInstance().getLogger().info("Private key loaded corresponds to address: " + credentials.getAddress());

        /* The contract wrappers generated by web3j don't include a chainId and are rejected by the
        remote node with "only replay-protected (EIP-155) transactions allowed over RPC". We fix this
        making a TransactionManager with the correct Polygon chainId. */
        TransactionObjects.polygonTransactionManager = new FastRawTransactionManager(
                NFTWorlds.getInstance().getPolygonRPC().getPolygonWeb3j(),
                credentials, 137);

        debug = nftWorlds.getNftConfig().isDebug();

        this.ethereumWRLDTokenContract = EthereumWRLDToken.load(
                config.getEthereumWrldContract(),
                nftWorlds.getEthereumRPC().getEthereumWeb3j(),
                credentials,
                ethereumRPC.getGasProvider()
        );

        this.polygonWRLDTokenContract = PolygonWRLDToken.load(
                config.getPolygonWrldContract(),
                nftWorlds.getPolygonRPC().getPolygonWeb3j(),
                TransactionObjects.polygonTransactionManager,
                new StaticGasProvider(BigInteger.valueOf(90_100_000_000L), BigInteger.valueOf(9_000_000))
        );

        this.startPolygonPaymentListener();
    }

    /**
     * > This function returns a `Disposable` object that can be used to unsubscribe from the `Flowable` object
     *
     * @return A disposable object that can be used to unsubscribe from the flowable.
     */
    public @NotNull Disposable getFlowableSubscription() {
        return flowableSubscription;
    }

    /**
     * This function returns the balance of the Ethereum wallet address passed in as a parameter
     *
     * @param walletAddress The wallet address of the user.
     * @return The balance of the wallet address.
     */
    public @NotNull BigInteger getEthereumBalance(@NotNull String walletAddress) throws Exception {
        return this.ethereumWRLDTokenContract.balanceOf(walletAddress).send();
    }

    /**
     * Get the balance of the Ethereum wallet address passed in as a parameter.
     *
     * The function is asynchronous, so it returns a CompletableFuture. The CompletableFuture is a Java class that
     * represents the result of an asynchronous computation
     *
     * @param walletAddress The address of the wallet you want to check the balance of.
     * @return A CompletableFuture object.
     */
    public @NotNull CompletableFuture<BigInteger> getEthereumBalanceAsync(@NotNull String walletAddress) {
        return this.ethereumWRLDTokenContract.balanceOf(walletAddress).sendAsync();
    }

    /**
     * > This function returns the balance of the Polygon WRLD token for the given wallet address
     *
     * @param walletAddress The wallet address of the user
     * @return The balance of the wallet address.
     */
    public @NotNull BigInteger getPolygonBalance(@NotNull String walletAddress) throws Exception {
        return this.polygonWRLDTokenContract.balanceOf(walletAddress).send();
    }

    /**
     * Get the balance of the Polygon wallet address passed in as a parameter.
     *
     * The function is asynchronous, so it returns a CompletableFuture. The CompletableFuture is a Java class that
     * represents the result of an asynchronous computation
     *
     * @param walletAddress The address of the wallet you want to check the balance of.
     * @return A CompletableFuture object.
     */
    public @NotNull CompletableFuture<BigInteger> getPolygonBalanceAsync(@NotNull String walletAddress) {
        return this.polygonWRLDTokenContract.balanceOf(walletAddress).sendAsync();
    }

    /**
     * > This function returns the PolygonWRLDToken contract
     *
     * @return The polygonWRLDTokenContract
     */
    public @NotNull PolygonWRLDToken getPolygonWRLDTokenContract() {
        return this.polygonWRLDTokenContract;
    }

    /*
     * Private
     */

    /**
     * Start listening for events on the Polygon blockchain,
     * and when you see a transfer event,
     * call the appropriate function to handle it.
     *
     * The first thing we do is create an EthFilter object. This object is used to tell the Polygon blockchain what events
     * we want to listen for. In this case, we want to listen for transfer events
     */
    private void startPolygonPaymentListener() {
        EthFilter transferFilter = new EthFilter(
                DefaultBlockParameterName.LATEST,
                DefaultBlockParameterName.LATEST,
                this.polygonWRLDTokenContract.getContractAddress()
        ).addOptionalTopics(WRLD.TRANSFER_REF_EVENT_TOPIC, WRLD.TRANSFER_EVENT_TOPIC);

        this.flowableSubscription = NFTWorlds.getInstance().getPolygonRPC().getPolygonWeb3j().ethLogFlowable(transferFilter)
                .subscribe(log -> {
                            String eventHash = log.getTopics().get(0);

                            if (eventHash.equals(TRANSFER_REF_EVENT_TOPIC)) {
                                this.paymentListener_handleTransferRefEvent(log);
                            } else if (eventHash.equals(TRANSFER_EVENT_TOPIC)) {
                                this.paymentListener_handleTransferEvent(log);
                            }
                        },
                        Throwable::printStackTrace
                );
    }

    @SuppressWarnings("rawtypes")
    private void paymentListener_handleTransferRefEvent(Log log) {
        final List<String> topics = log.getTopics();
        final TypeReference<Address> addressTypeReference = new TypeReference<>() {};
        final Address fromAddress = (Address) FunctionReturnDecoder.decodeIndexedValue(topics.get(1), addressTypeReference);
        final Address toAddress = (Address) FunctionReturnDecoder.decodeIndexedValue(topics.get(2), addressTypeReference);

        final List<Type> data = FunctionReturnDecoder.decode(log.getData(), PolygonWRLDToken.TRANSFERREF_EVENT.getNonIndexedParameters());
        final Uint256 amount = (Uint256) data.get(0);
        final Uint256 ref = (Uint256) data.get(1);
        final double received = Convert.fromWei(amount.getValue().toString(), Convert.Unit.ETHER).doubleValue();

        LogUtil.log("Transfer initiated");
        LogUtil.log("Transfer of %s $WRLD with refID %s from %s to %s", received, ref.getValue().toString(), fromAddress.toString(), toAddress.toString());

        final PaymentRequest<?> paymentRequest = PaymentRequest.getPayment(ref, Network.POLYGON);
        if (Objects.nonNull(paymentRequest)) {
            LogUtil.log("Transfer found in payment requests");
            LogUtil.log("Requested: %s, Received: %s", paymentRequest.getAmount(), received);

            if (paymentRequest.getAmount() == received) {
                LogUtil.log("Payment amount verified");

                if (!paymentRequest.isCanDuplicate()) {
                    PaymentRequest.getPaymentRequests().remove(paymentRequest);
                }

                LogUtil.log("Event fired");
                Bukkit.getScheduler().runTask(NFTWorlds.getInstance(), () -> {
                    final OfflinePlayer player = Bukkit.getOfflinePlayer(paymentRequest.getAssociatedPlayer());
                    new PlayerTransactEvent<>(
                            player,
                            received,
                            paymentRequest.getReason(),
                            ref,
                            paymentRequest.getPayload()
                    ).callEvent(); //TODO: Test if works for offline players
                });
                return;
            }

            LogUtil.log(Level.WARNING, "Payment with REFID %s was receive but amount was %s. Expected %s", ref.getValue().toString(), received, paymentRequest.getAmount());
            return;
        }

        // Now let's check if this is a peer to peer payment
        final PeerToPeerPayment peerToPeerPayment = PeerToPeerPayment.getPayment(ref, Network.POLYGON);

        if (Objects.nonNull(peerToPeerPayment)) {
            LogUtil.log("Transfer found in peer to peer payments");
            LogUtil.log("Requested: %s, Received: %s", peerToPeerPayment.getAmount(), received);

            if (peerToPeerPayment.getAmount() != received) {
                LogUtil.log("Amount expected was different than amount received, value adjusted.");
                peerToPeerPayment.setAmount(received);
            }

            PeerToPeerPayment.getPeerToPeerPayments().remove(peerToPeerPayment);

            LogUtil.log("Event fired");
            Bukkit.getScheduler().runTask(NFTWorlds.getInstance(), () -> {
                new PeerToPeerPayEvent(
                        Bukkit.getOfflinePlayer(peerToPeerPayment.getTo()),
                        Bukkit.getOfflinePlayer(peerToPeerPayment.getFrom()),
                        received,
                        peerToPeerPayment.getReason(),
                        ref
                ).callEvent(); //TODO: Test if works for offline players
            });
        }
    }

    @SuppressWarnings("rawtypes")
    private void paymentListener_handleTransferEvent(Log log) {
        final NFTWorlds plugin = NFTWorlds.getInstance();

        final List<String> topics = log.getTopics();
        final TypeReference<Address> addressTypeReference = new TypeReference<>() {};
        final Address fromAddress = (Address) FunctionReturnDecoder.decodeIndexedValue(topics.get(1), addressTypeReference);
        final Address toAddress = (Address) FunctionReturnDecoder.decodeIndexedValue(topics.get(2), addressTypeReference);

        // If this transaction is not related to OUR server, ignore it.
        if (!this.isServerAddress(fromAddress, toAddress))
            return;

        final List<Type> data = FunctionReturnDecoder.decode(log.getData(), PolygonWRLDToken.TRANSFER_EVENT.getNonIndexedParameters());
        final Uint256 amount = (Uint256) data.get(0);
        final double received = Convert.fromWei(amount.getValue().toString(), Convert.Unit.ETHER).doubleValue();

        LogUtil.log("Transfer of %s $WRLD from %s to %s.", received, fromAddress, toAddress);

        final Wallet fromWallet = plugin.getWallet(fromAddress.toString());
        if (Objects.nonNull(fromWallet)) {
            fromWallet.setPolygonWRLDBalance(fromWallet.getPolygonWRLDBalance() - received);
        }

        final Wallet toWallet = plugin.getWallet(toAddress.toString());
        if (Objects.nonNull(toWallet)) {
            toWallet.setPolygonWRLDBalance(toWallet.getPolygonWRLDBalance() + received);
        }
    }

    private boolean isServerAddress(Address from, Address to) {
        final String serverAddress = NFTWorlds.getInstance().getNftConfig().getServerWalletAddress();
        return (Objects.nonNull(from) && from.toString().equals(serverAddress)) ||
                (Objects.nonNull(to) && to.toString().equalsIgnoreCase(serverAddress));
    }
}
